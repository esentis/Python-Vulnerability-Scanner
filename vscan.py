import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
from sslyze import ServerNetworkLocationViaDirectConnection, ServerConnectivityTester, Scanner, ServerScanRequest, \
    ScanCommand
from sslyze.errors import ConnectionToServerFailed
import scanner
import optparse
from halo import Halo

parser = optparse.OptionParser()
links_to_ignore = ["http://10.0.2.19/dvwa/logout.php"]
style = scanner.bcolors

print(scanner.bcolors.HEADER+scanner.bcolors.UNDERLINE + "Vulnerability Scanner" + scanner.bcolors.ENDC)
# Here we define the arguments passed in CLI
def get_arguments():
    parser.add_option("-u", "--url", dest="url", help="URL Στόχου")
    (options, arguments) = parser.parse_args()
    if not options.url:
        parser.error(style.BOLD + style.FAIL +"\n\n Παρακαλώ βάλτε διεύθυνση\n"
                     + style.OKBLUE + scanner.bcolors.BOLD + "Για παράδειγμα :"
                     + style.BOLD + "python3 vscan.py -u www.iee.ihu.gr\n\n" + style.ENDC)
    return options


options = get_arguments()


spinner = Halo(text="Looking for links in " + options.url, spinner='dots')

spinner.start()

# Target url that user passes , expected the URL without http://
# target_url = "http://" + options.url
target_url = options.url
# Create a new scanner with the given url
my_scanner = scanner.Scanner(target_url, links_to_ignore)
# Crawl the website to get all the links
my_scanner.crawl(target_url)
my_scanner.run_scanner()


# Success message for links
spinner.succeed("Links generated")
# New spinner for getting HTML page
spinner = Halo(text="Getting HTML from " + options.url, spinner='dots')
# Spinner for getting HTML page starts
spinner.start()

# Spinner for getting inputs
spinner = Halo(text="Getting inputs", spinner='dots')
# Spinner for getting inputs start
spinner.start()


spinner.succeed("Input fields found")
# target_url2 = "http://10.0.2.19/dvwa/about.php"

# Spinner for getting inputs
spinner = Halo(text="Posting data at "+target_url, spinner='dots')
# Spinner for getting inputs start
spinner.start()


spinner.succeed("Data posted")

# # Spinner for setting up connection with server
# spinner = Halo(text="Connecting to server for analyse "+target_url, spinner='dots')
# # Spinner for getting inputs start
# spinner.start()
# spinner = Halo(text="Searching open ports", spinner='dots')
# spinner.start()
# results_nmap = nmap.scan_top_ports("10.0.2.19")
# print(results_nmap)
# spinner.succeed(text="Ports found")
# spinner = Halo(text="Searching version", spinner='dots')

# spinner.start()
# results_version = nmap.nmap_version_detection("10.0.2.19")
# print(results_version)
# spinner.succeed(text="Version found")

# spinner = Halo(text="Searching for list", spinner='dots')
# spinner.start()
# results_list = nmap.nmap_list_scan("10.0.2.19")
# print(results_list)
# spinner.succeed(text="List found")

# Here starts SSLyze code


# # Removing http:// so sslyze can work
# if target_url.startswith("http://"):
#     target_url = target_url[+7:]
#
# # Define the server that you want to scan
# server_location = ServerNetworkLocationViaDirectConnection.with_ip_address_lookup(target_url, 443)
#
# # Do connectivity testing to ensure SSLyze is able to connect
# try:
#     server_info = ServerConnectivityTester().perform(server_location)
# except ConnectionToServerFailed as e:
#     # Could not connect to the server; abort
#     print(f"Error connecting to {server_location}: {e.error_message}")
#     pass
#
# # Then queue some scan commands for the server
# scanner = Scanner()
# server_scan_req = ServerScanRequest(
#     server_info=server_info, scan_commands={ScanCommand.CERTIFICATE_INFO
#         , ScanCommand.SSL_2_0_CIPHER_SUITES
#         , ScanCommand.SSL_3_0_CIPHER_SUITES
#         , ScanCommand.HEARTBLEED
#         , ScanCommand.OPENSSL_CCS_INJECTION
#         , ScanCommand.HTTP_HEADERS
#                                             },
# )
# scanner.queue_scan(server_scan_req)
#
#
# # Then retrieve the results
# for server_scan_result in scanner.get_results():
#     print(f"\nResults for {server_scan_result.server_info.server_location.hostname}:")
#     spinner.succeed("Analyse completed")
#     spinner = Halo(text="SSL 2.0 Vulnerability Check\n", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#
#     # SSL 2.0 results
#     ssl2_result = server_scan_result.scan_commands_results[ScanCommand.SSL_2_0_CIPHER_SUITES]
#     print(f"\nAccepted cipher suites for SSL 2.0:")
#     print(style.OKBLUE+"\nPreferred Cipher Suite\n")
#     if ssl2_result.cipher_suite_preferred_by_server is None:
#         print(style.FAIL+"\nNo preferred Cipher Suite found\n")
#     else:
#         print(style.OKGREEN+ssl2_result.cipher_suite_preferred_by_server)
#     for accepted_cipher_suite in ssl2_result.accepted_cipher_suites:
#         print(style.OKGREEN+f"Name* {accepted_cipher_suite.cipher_suite.name}")
#         print(style.OKGREEN+f"OpenSSL Name* {accepted_cipher_suite.cipher_suite.openssl_name}")
#         print(style.OKGREEN+f"Is it Anonymous* {accepted_cipher_suite.cipher_suite.is_anonymous}")
#         print(style.OKGREEN+f"Key Size* {accepted_cipher_suite.cipher_suite.key_size}")
#     print(style.FAIL+"Rejected suites :\n")
#     for accepted_cipher_suite in ssl2_result.rejected_cipher_suites:
#         print(style.FAIL+f"Name* {accepted_cipher_suite.cipher_suite.name}")
#         print(style.FAIL+f"OpenSSL Name* {accepted_cipher_suite.cipher_suite.openssl_name}")
#         print(style.FAIL+f"Is it Anonymous* {accepted_cipher_suite.cipher_suite.is_anonymous}")
#         print(style.FAIL+f"Key Size* {accepted_cipher_suite.cipher_suite.key_size}")
#     spinner.succeed(text="SSL 2.0 Vulnerability Check Complete\n")
#
#     spinner = Halo(text="SSL 3.0 Vulnerability Check\n", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#     # SSL 3.0 results
#     print("\n")
#     ssl3_result = server_scan_result.scan_commands_results[ScanCommand.SSL_3_0_CIPHER_SUITES]
#     print(f"\nAccepted cipher suites for SSL 3.0:")
#     print(style.OKBLUE + "\nPreferred Cipher Suite\n")
#     if ssl3_result.cipher_suite_preferred_by_server is None:
#         print(style.FAIL + "\nNo preferred Cipher Suite found\n")
#     else:
#         print(style.OKGREEN + ssl3_result.cipher_suite_preferred_by_server)
#     for accepted_cipher_suite in ssl3_result.accepted_cipher_suites:
#         print(style.OKGREEN + f"Name* {accepted_cipher_suite.cipher_suite.name}")
#         print(style.OKGREEN + f"OpenSSL Name* {accepted_cipher_suite.cipher_suite.openssl_name}")
#         print(style.OKGREEN + f"Is it Anonymous* {accepted_cipher_suite.cipher_suite.is_anonymous}")
#         print(style.OKGREEN + f"Key Size* {accepted_cipher_suite.cipher_suite.key_size}")
#     print(style.FAIL + "Rejected suites :\n")
#     for accepted_cipher_suite in ssl3_result.rejected_cipher_suites:
#         print(style.FAIL + f"Name* {accepted_cipher_suite.cipher_suite.name}")
#         print(style.FAIL + f"OpenSSL Name* {accepted_cipher_suite.cipher_suite.openssl_name}")
#         print(style.FAIL + f"Is it Anonymous* {accepted_cipher_suite.cipher_suite.is_anonymous}")
#         print(style.FAIL + f"Key Size* {accepted_cipher_suite.cipher_suite.key_size}")
#     spinner.succeed(text="SSL 3.0 Vulnerability Check Complete")
#
#
#
#     spinner = Halo(text="Certificate Check", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#     # Certificate info results
#     certinfo_result = server_scan_result.scan_commands_results[ScanCommand.CERTIFICATE_INFO]
#     print("\nCertificate info:")
#
#     # A list of leaf certificate detected by SSLyze and the corresponding analysis.
#     # Most servers only deploy one leaf certificate,
#     # but some websites (such as Facebook) return different leaf certificates
#     # depending on the client, as a way to maximize compatibility with older clients/devices.
#     for cert_deployment in certinfo_result.certificate_deployments:
#         print(style.BOLD+"\nTRUST STORES")
#         for path_validation_results in cert_deployment.path_validation_results:
#             print(style.OKGREEN+path_validation_results.trust_store.name)
#             if path_validation_results.was_validation_successful:
#                 print(style.OKGREEN + "Validation successful !")
#             else:
#                 print(style.FAIL + "Validation failed !")
#
#             print(style.OKGREEN+"Version : "+str(path_validation_results.trust_store.version))
#             if path_validation_results.openssl_error_string is None:
#                 print(style.OKGREEN+"No OpenSSL Errors found")
#             else:
#                 print(style.FAIL+path_validation_results.openssl_error_string)
#             print("\n")
#     spinner.succeed(text="Certificate Check Complete")
#
#     spinner = Halo(text="Heartbleed Check", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#     # Heartbleed results
#     heartbleed_result = server_scan_result.scan_commands_results[ScanCommand.HEARTBLEED]
#
#     if not heartbleed_result.is_vulnerable_to_heartbleed:
#         spinner.succeed(text="Safe from heartbleed vulnerability")
#     else:
#         spinner.fail(text="Heartbleed vulnerability is present")
#
#     spinner = Halo(text="OpenSSL Injection Check", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#     # OpenSSL Injection results
#     openssl_injection_results = server_scan_result.scan_commands_results[ScanCommand.OPENSSL_CCS_INJECTION]
#
#     print(openssl_injection_results)
#     spinner.succeed(text="OpenSSL Injection Check Complete")
#
#     spinner = Halo(text="HTTP Headers Check", spinner='dots')
#     spinner.color = "red"
#     spinner.start()
#     # OpenSSL Injection results
#     http_headers_results = server_scan_result.scan_commands_results[ScanCommand.HTTP_HEADERS]
#     print(http_headers_results)
#     spinner.succeed(text="HTTP Headers Check Complete")